
JavaScript中的范围链、闭包

一  三个必要概念

1  global variable 全局变量
JS解析器开始工作时，在执行JS代码之前要做的第一件事就是创建全局对象。这个对象的属性就是JS程序中的全局变量。当你声明一个全局变量时，你实际上就是在定义这个全局对象中的一个属性。例如，parseInt math
在下面的‘范围链’概念里，将说明全局变量是怎么起到‘全局’的作用的。

2  local variable 局部变量
JS解析器在执行一个函数时，会为这个函数产生一个专门的对象，一般称作调用对象(call object)。函数中的每个参数、函数体中的每个用var关键字定义的变量都会放在这个调用对象的属性中。这些变量因为被定义在这些对象中，因而只能为这个对象所调用，所以这些变量就是局部变量。
在下面讲过‘范围链’之后，再继续解释这个调用对象。

3  execution contexts 执行上下文
执行上下文就是JS代码所执行的上下文环境。
比如说，最上层的JS代码运行在使用了全局对象的执行上下文中，而JS函数都运行在独属于自己的执行上下文中。

二  scope chain 范围链

1  范围链是什么

	每一个JS上下文都有一个和与之关联的范围链。范围链是一些对象的一个列表或者一个链条。当JS代码需要找到一个变量x的值时，它先在这个范围链的第一个对象中找。如果这个对象有一个叫做x的属性，这个属性的值就被程序使用。如果这第一个对象中没有被命名为x的属性，JS继续在这个范围链中的第二个对象中寻找。如果这第二个对象仍然没有属性x，JS程序将在第三个对象中寻找，以此类推。实际上范围链是在定义在JavaScript中查找变量的路径机制。不同的上下文环境中，范围链的表现是不同的。一共有三种上下文情况，下面分别说明它们的范围链是由什么对象构成的。

2  三种上下文情况中的范围链

   a 在最顶层的不包含函数的JS代码中
	它的范围链中只有一个全局对象。所有变量都在这个对象中找，如果变量没有在其中发现，这个变量值就是undefined。

   b 在不是嵌套函数的函数中
	它的范围链有两个对象组成，从顶端到末端分别是：该函数的调用对象，全局对象。当在该函数中调用一个变量时，先在调用对象中查找，然后再在全局对象中查找。

   c 在嵌套函数中
	它的范围链中有三个或者更多的对象，从顶端到末端至少应包含：嵌套函数的调用对象、父层函数的调用对象、全局对象。

	现在我们了解了范围链的概念，下面我们先说明下在JavaScript中一个普通函数是如何工作的，然后我们引入对闭包的讲解。

三  在JavaScript中函数是如何工作的

	1  当JS文件载入到浏览器里后，JS解析器读取JS文件中的代码。当遇到函数定义时，JS解析器就生成符合这个函数上下文情景的一个范围链并存储起来。
	
	2  当用户调用这个函数时，或者说当JS解析器执行这个函数时，JS解析器会设置这个函数所对应的范围链。对普通函数来说，这个范围链里仅仅会有全局对象；对嵌套函数来说，这个范围链里有外层函数的调用对象和全局对象。 

	3  接下来，JS解析器在这个范围链(scope chain)的顶端添加一个被称为调用对象(call object)的对象（在ECMAScript上用的是’激活对象(activation object)’这个词）。
	4  然后对这个调用对象进行初始化
		设置一个叫做arguments的属性，这个属性就是指函数的参数对象，函数的参数加到其中
		函数体中所有被var关键字声明的变量被加到调用对象的属性中

	5  JS解析器通过使用范围链中的各个对象来执行这个函数

	6  当这个函数执行了return关键字时，JS解析器会执行两个操作：一个是返回return关键字后面的数据值，一个是停止执行这个函数

	7  因为函数不再被使用，它的范围链及范围链中的调用对象和全局对象仅仅彼此引用，根据垃圾收集机制中的规则，范围链中的所有对象将进入垃圾收集机制进行销毁。
	8  当再次调用这个函数时，会重新设置这个函数的范围链，再在其中添加调用对象和全局对象以供使用。

	这个工作流程是针对普通函数说的，如果对于那些含有嵌套函数、并且还以变量的形式使用它的话，比如用return关键字把嵌套函数返回或者用参数传进，那么这个工作流程就有些许不同了。同时这也会引出一个被称为’闭包’的技术。

四  closures 闭包  

	
	1  嵌套函数的范围链都包含了哪些对象

		这是一个嵌套函数的通常情景：
		在一个函数f中定义了一个函数g。
		var x = "global";
		function f() {
			var x = "local";
			function g() { alert(x); }
			g();
		}
		f();  // 显示出 "local"
		当函数f被调用时，其范围链中有两个对象：处在前面的是函数f的调用对象(call object)，后面跟随着全局对象。因为函数g是在函数f中定义的，所以函数f的范围链也就成为了函数g的范围链中的一部分。当函数g被调用时，函数g的范围链就包括了如下对象，从前到后依次是：1 函数g的调用对象  2 函数f的调用对象 3 全局对象。

	2  闭包是什么  

		在JavaScript中，函数也是一种数据，就如同数字、字符串一样，因而函数不仅可以存储在数组中，还可以被定义到对象属性中，也可以被函数所返回。在通常情况下，函数的这种特性并没有引起特别令人惊奇的应用，但当这种特性被应用到被嵌套的函数上时就出现了被称为‘’闭包’的用法。我们看下面这个返回了一个被嵌套的函数的代码：

		function makefunc(x) {
			return function() { return x; }
		}
		var a = [makefunc(0), makefunc(1), makefunc(2)];

		a[0] = function() { return 0; }
		alert(a[0]());  // 显示 0

		a[1] = function() { return 1; }
		alert(a[1]());  // 显示 1
			
		a[2] = function() { return 2; }
		alert(a[2]());  // 显示 2

		makefunc()函数包含了一个函数并返回了它。如果这个嵌套函数只是在makefunc()中使用，没有被返回给变量a的话，那么当makefunc()结束执行时，与这个嵌套函数对应的调用对象，因为仅仅被外层函数的范围链唯一引用而被垃圾收集机制检测到，并最终被垃圾收集机制所销毁。但是如果嵌套函数被返回并赋值给一个变量a的话，那么垃圾收集机制将检测到这个嵌套函数不仅被外层函数引用，还被另一个外部变量a所引用，因而这个嵌套函数就不能被垃圾收集机制销毁。这也就意味着，嵌套函数的范围链也会因此保留下来，而且外层函数的调用对象也因为嵌套函数的范围链被保留而同时被保留下来了。

		在JavaScript中，函数是执行代码和执行这些代码的范围的混合体。这个代码和范围的混合体在计算机科学的术语中就叫做闭包。比如在PHP中也有闭包的概念。从概念上讲所有的JavaScript函数都是闭包，但这些闭包仅仅是叫法而已。而在我们上面讨论中：当一个嵌套函数被它所在的外层函数返回而保留下来并使用时，这个函数才是一个明了的闭包。
		闭包是一个有趣和强大的技术。尽管它们并不常见于日常JS编程中，但它们仍然值得我们学习。

	3  closures example 闭包应用的例子

	1)  要一个全局性的变量，并令每次使用它时其值均不同，并且这个变量值不能被人为更改

		用一般函数的方法
		uniqueID = function() {
			if (!arguments.callee.id) {
				arguments.callee.id = 0;
			}
			return arguments.callee.id++;
		};
		说明：使用函数的属性，每次调用uniqueID()时，均在该变量上加1
		缺点：可以通过uniqueID.id被设置					

		用闭包的方法
		uniqueID = (function() {  
			var id = 0;
			return function() { return id++; };  
		})(); 
		说明：匿名函数定义后即执行，返回里面嵌套的函数。在匿名函数中定义一个它的局部变量，在嵌套函数中自增这个变量，并作为嵌套函数的返回值。使用时用uniqueID()。
					
	2)  创建一个私有持久变量   

		说明：为对象设置一对setter和getter方法
					
		function makeProperty(o, name, predicate) {

			// 这是属性值
			var value;  

			// getter 方法
			o["get" + name] = function() { 
				return value; 
			};

			// setter 方法 设置值或者当数值验证不通过时抛出异常
			o["set" + name] = function(v) {
				if (predicate && !predicate(v)) {
					throw "set" + name + ": invalid value " + v;
				} else {
					value = v;
				}
			};
		}

		// 演示 makeProperty() 
		var o = {};  // 建立一个空对象

		// 为对象o增加一对属性存取器 getName and setName()，并确保该属性必须是字符串类型
		makeProperty(o, "Name", function(x) { return typeof x == "string"; });
		o.setName("Frank");  // 设置一个属性值
		print(o.getName());  // 获取一个属性值
		o.setName(0);        // 尝试设置一个错误的属性值
	

	4 在IE浏览器中对闭包的循环使用将会造成内存泄露并导致浏览器崩溃，用命令 delete 适时删除变量

	